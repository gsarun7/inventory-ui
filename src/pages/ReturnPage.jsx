import React, { useEffect, useState } from "react";
import {
  Box,
  Container,
  Paper,
  Typography,
  Divider,
  Button,
} from "@mui/material";
import ReturnForm from "../components/Returns/ReturnForm";
import ReturnPreview from "../components/Returns/ReturnPreview";
import apiClient from "../services/apiClient";

export default function ReturnPage() {
  const [categories, setCategories] = useState([]);
  const [warehouses, setWarehouses] = useState([]);
  const [invoices, setInvoices] = useState([]);
  const [soldItems, setSoldItems] = useState([]);
  const [isSaving, setIsSaving] = useState(false);

  const [form, setForm] = useState({
    returnId: "", // âœ… Empty - will be generated by backend
    returnDate: new Date().toISOString().slice(0, 10),
    originalInvoiceNo: "",
    originalInvoiceDate: "",
    customerId: null,
    customerName: "",
    customerPhone: "",
    customerAddress: "",
    warehouse: "",
    returnReason: "",
    returnCondition: "GOOD",
    refundMethod: "CASH",
    refundAmount: "0.00",
    notes: "",
    items: [
      {
        warehouse: "",
        categoryId: "",
        itemId: "",
        itemName: "",
        soldQty: 0,
        returnQty: 0,
        unitPrice: 0,
        totalPrice: 0,
        condition: "GOOD",
      },
    ],
  });

  // Load initial data
  useEffect(() => {
    apiClient.get("/api/categories").then((r) => setCategories(r.data));
    apiClient.get("/api/warehouses").then((r) => setWarehouses(r.data));
  }, []);

  // Handle invoice selection - fetch full invoice details
  const handleInvoiceSelect = async (invoiceId) => {
    try {
      console.log("Fetching invoice details for ID:", invoiceId);

      const response = await apiClient.get(
        `/api/sales_invoices/${invoiceId}/items`
      );
      const invoiceDetails = response.data;

      console.log("Invoice details received:", invoiceDetails);

      if (invoiceDetails) {
        setSoldItems(invoiceDetails.items || []);

        const items = (invoiceDetails.items || []).map((item) => ({
          warehouse: invoiceDetails.warehouse?.id || form.warehouse || "",
          categoryId: item.categoryId || "",
          itemId: item.productId || item.itemId,
          itemName: item.productName || item.itemName || "",
          soldQty: item.quantity || 0,
          returnQty: 0,
          unitPrice: item.rate || item.unitPrice || 0,
          totalPrice: 0,
          condition: "GOOD",
        }));

        setForm((prev) => ({
          ...prev,
          warehouse: invoiceDetails.warehouse?.id || prev.warehouse,
          items: items.length > 0 ? items : prev.items,
          refundAmount: "0.00",
        }));
      }
    } catch (error) {
      console.error("Error loading invoice details:", error);
      alert("Failed to load invoice details. Please try again.");
    }
  };

  const updateField = (key, value) => setForm((p) => ({ ...p, [key]: value }));

  const updateItem = (index, key, value) => {
    const items = [...form.items];

    if (typeof key === "object") {
      items[index] = { ...items[index], ...key };
    } else {
      items[index] = { ...items[index], [key]: value };
    }

    if (key === "returnQty" || key === "unitPrice") {
      const returnQty = parseFloat(items[index].returnQty || 0);
      const unitPrice = parseFloat(items[index].unitPrice || 0);

      if (!isNaN(returnQty) && !isNaN(unitPrice)) {
        items[index].totalPrice = (returnQty * unitPrice).toFixed(2);
      }
    }

    setForm((p) => ({ ...p, items }));
  };

  useEffect(() => {
    const totalRefund = form.items.reduce((sum, item) => {
      return sum + parseFloat(item.totalPrice || 0);
    }, 0);

    setForm((p) => ({
      ...p,
      refundAmount: totalRefund.toFixed(2),
    }));
  }, [form.items]);

  const addItemRow = () => {
    setForm((p) => ({
      ...p,
      items: [
        ...p.items,
        {
          warehouse: p.warehouse || "",
          categoryId: "",
          itemId: "",
          itemName: "",
          soldQty: 0,
          returnQty: 0,
          unitPrice: 0,
          totalPrice: 0,
          condition: "GOOD",
        },
      ],
    }));
  };

  const removeItemRow = (index) => {
    if (form.items.length === 1) {
      alert("At least one item is required");
      return;
    }
    const items = form.items.filter((_, i) => i !== index);
    setForm((p) => ({ ...p, items }));
  };

  const handlePrint = () => {
    window.print();
  };

  const handleSubmitInvoice = async () => {
    try {
      // Validation
      if (!form.customerId) {
        alert("Please select a customer");
        return;
      }
      if (!form.originalInvoiceNo) {
        alert("Please select an invoice");
        return;
      }
      if (!form.returnReason) {
        alert("Please select a return reason");
        return;
      }

      const hasReturnItems = form.items.some(
        (item) => parseFloat(item.returnQty) > 0
      );
      if (!hasReturnItems) {
        alert("Please enter return quantity for at least one item");
        return;
      }

      const invalidItems = form.items.filter(
        (item) => parseFloat(item.returnQty) > parseFloat(item.soldQty)
      );
      if (invalidItems.length > 0) {
        alert("Return quantity cannot exceed sold quantity");
        return;
      }

      setIsSaving(true);

      const payload = {
        // âŒ Don't send returnId - backend will generate it
        salesInvoiceNo: form.originalInvoiceNo,
        salesInvoiceDate: form.originalInvoiceDate,
        customerId: parseInt(form.customerId),
        warehouseId: parseInt(form.warehouse),
        returnDate: form.returnDate,
        returnReason: form.returnReason,
        returnCondition: form.returnCondition,
        refundMethod: form.refundMethod,
        refundAmount: parseFloat(form.refundAmount),
        notes: form.notes,
        items: form.items
          .filter((item) => parseFloat(item.returnQty) > 0)
          .map((item) => ({
            productId: parseInt(item.itemId),
            soldQuantity: parseFloat(item.soldQty),
            returnQuantity: parseFloat(item.returnQty),
            unitPrice: parseFloat(item.unitPrice),
            totalRefund: parseFloat(item.totalPrice),
            condition: item.condition,
          })),
      };

      console.log("ðŸ“¤ Submitting return:", payload);

      const response = await apiClient.post("/api/sales-return", payload);

      // âœ… Update form with generated return ID
      setForm((prev) => ({
        ...prev,
        returnId: response.data.returnId || response.data.returnNo,
      }));

      setIsSaving(false);
      alert(
        `âœ… Return ${
          response.data.returnId || response.data.returnNo
        } processed successfully!`
      );

      // Optionally clear form after successful save
      // handleClearForm();
    } catch (err) {
      console.error("Error saving return:", err);
      setIsSaving(false);
      alert(err.response?.data?.message || "Failed to process return");
    }
  };

  const handleClearForm = () => {
    setForm({
      returnId: "",
      returnDate: new Date().toISOString().slice(0, 10),
      originalInvoiceNo: "",
      originalInvoiceDate: "",
      customerId: null,
      customerName: "",
      customerPhone: "",
      customerAddress: "",
      warehouse: "",
      returnReason: "",
      returnCondition: "GOOD",
      refundMethod: "CASH",
      refundAmount: "0.00",
      notes: "",
      items: [
        {
          warehouse: "",
          categoryId: "",
          itemId: "",
          itemName: "",
          soldQty: 0,
          returnQty: 0,
          unitPrice: 0,
          totalPrice: 0,
          condition: "GOOD",
        },
      ],
    });
    setSoldItems([]);
  };

  return (
    <Container maxWidth="lg" sx={{ mt: 3 }}>
      <style>{`
        @media print {
          body * { visibility: hidden; }
          .printable-area, .printable-area * { visibility: visible; }
          .printable-area { position: absolute; left: 0; top: 0; width: 100%; }
        }
        .return-preview-root { margin-top: 16px; }
      `}</style>

      <Paper sx={{ p: 3 }}>
        <Typography variant="h5" gutterBottom>
          Product Return Processing
        </Typography>
        <Typography variant="body2" color="text.secondary" gutterBottom>
          Process customer returns, restock inventory, and issue refunds. Live
          preview below updates instantly.
        </Typography>

        <Divider sx={{ mb: 2 }} />

        <ReturnForm
          form={form}
          categories={categories}
          warehouses={warehouses}
          soldItems={soldItems}
          invoices={invoices}
          updateField={updateField}
          updateItem={updateItem}
          addItemRow={addItemRow}
          removeItemRow={removeItemRow}
          onInvoiceSelect={handleInvoiceSelect}
        />

        <Box className="return-preview-root">
          <Typography variant="h6" sx={{ mt: 2 }}>
            Return Voucher Preview
          </Typography>
          <ReturnPreview data={form} className="printable-area" />

          <Box sx={{ mt: 2, display: "flex", gap: 2, flexWrap: "wrap" }}>
            <Button
              variant="contained"
              onClick={handleSubmitInvoice}
              disabled={isSaving || !form.customerId || !form.originalInvoiceNo}
            >
              {isSaving ? "Processing..." : "Process Return"}
            </Button>

            <Button variant="contained" onClick={handlePrint}>
              Print Voucher
            </Button>

            <Button variant="outlined" color="error" onClick={handleClearForm}>
              Clear All
            </Button>
          </Box>
        </Box>
      </Paper>
    </Container>
  );
}
